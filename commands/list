#!/usr/bin/env node
const { readdir } = require('node:fs/promises')
const { readFile, writeFile } = require('node:fs/promises')
const { join } = require('node:path')
const { existsSync } = require('node:fs')
const readline = require('readline')

const CACHE_DIR = join(require('os').homedir(), '.vps', 'cache')
const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

async function ensureCacheDir() {
  const { mkdir } = require('node:fs/promises')
  try {
    await mkdir(CACHE_DIR, { recursive: true })
  } catch (error) {
    // Directory already exists
  }
}

async function getCachedVPSList(providerName) {
  const cacheFile = join(CACHE_DIR, `${providerName}.json`)
  
  if (!existsSync(cacheFile)) {
    return null
  }
  
  try {
    const data = await readFile(cacheFile, 'utf8')
    const cached = JSON.parse(data)
    const age = Date.now() - cached.timestamp
    
    if (age < CACHE_TTL) {
      return cached.vpses
    }
  } catch (error) {
    // Cache file is invalid, ignore
  }
  
  return null
}

async function setCachedVPSList(providerName, vpses) {
  await ensureCacheDir()
  const cacheFile = join(CACHE_DIR, `${providerName}.json`)
  
  const data = {
    timestamp: Date.now(),
    vpses
  }
  
  await writeFile(cacheFile, JSON.stringify(data, null, 2))
}

async function loadCredentials(serviceName) {
  try {
    const keytar = require('keytar')
    const credentials = await keytar.findCredentials(serviceName)
    if (credentials && credentials.length > 0) {
      return {
        username: credentials[0].account,
        password: credentials[0].password
      }
    }
  } catch (error) {
    // keytar not available, continue without saved credentials
  }
  return null
}

async function promptCredentials(providerName) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  })

  return new Promise((resolve) => {
    rl.question(`Username: `, (username) => {
      const originalWriteToOutput = rl._writeToOutput
      rl._writeToOutput = function _writeToOutput(stringToWrite) {
        if (stringToWrite === '\n' || stringToWrite === '\r\n') {
          rl.output.write(stringToWrite)
        } else if (stringToWrite !== 'Password: ') {
          rl.output.write('*')
        } else {
          rl.output.write(stringToWrite)
        }
      }
      
      rl.question(`Password: `, (password) => {
        rl._writeToOutput = originalWriteToOutput
        rl.output.write('\n')
        rl.close()
        resolve({ username, password })
      })
    })
  })
}

async function saveCredentials(serviceName, username, password) {
  try {
    const keytar = require('keytar')
    await keytar.setPassword(serviceName, username, password)
  } catch (error) {
    // Ignore if keytar is not available
  }
}

function formatVPSList(vpses, providerName) {
  if (!vpses || vpses.length === 0) {
    console.log(`No VPSes found for ${providerName}`)
    return
  }
  
  // ANSI color codes
  const grey = '\x1b[90m'
  const green = '\x1b[32m'
  const reset = '\x1b[0m'
  
  // Calculate column widths
  const ipWidth = Math.max(15, ...vpses.map(v => (v.ip || 'N/A').length))
  const nameWidth = Math.max(30, ...vpses.map(v => (v.name || v.plan || 'N/A').length))
  const statusWidth = Math.max(10, ...vpses.map(v => (v.status || 'Unknown').length))
  const pricingWidth = Math.max(20, ...vpses.map(v => (v.pricing || 'N/A').length))
  const providerWidth = Math.max(10, ...vpses.map(v => (v.provider || 'N/A').length))
  
  // Print header
  console.log(
    'IP ADDRESS'.padEnd(ipWidth) + '   ' +
    'NAME'.padEnd(nameWidth) + '   ' +
    'STATUS'.padEnd(statusWidth) + '   ' +
    'PRICING'.padEnd(pricingWidth) + '   ' +
    'PROVIDER'
  )
  
  // Print each VPS
  for (const vps of vpses) {
    const ip = (vps.ip || 'N/A').padEnd(ipWidth)
    const name = (vps.name || vps.plan || 'N/A').padEnd(nameWidth)
    const statusText = (vps.status || 'Unknown').padEnd(statusWidth)
    const pricing = (vps.pricing || 'N/A').padEnd(pricingWidth)
    const provider = (vps.provider || 'N/A').padEnd(providerWidth)
    
    // Apply colors based on status
    const isCancelled = vps.status === 'Cancelled'
    const isActive = vps.status === 'Active'
    
    if (isCancelled) {
      // Grey out entire row for cancelled services
      console.log(`${grey}${ip}   ${name}   ${statusText}   ${pricing}   ${provider}${reset}`)
    } else if (isActive) {
      // Green "Active" status only
      const statusColored = `${green}${statusText}${reset}`
      console.log(`${ip}   ${name}   ${statusColored}   ${pricing}   ${provider}`)
    } else {
      // Default - no coloring
      console.log(`${ip}   ${name}   ${statusText}   ${pricing}   ${provider}`)
    }
  }
}

async function listProviders() {
  const providersDir = join(__dirname, '../providers')
  try {
    const files = await readdir(providersDir)
    return files
      .filter(file => file !== '.gitkeep' && !file.startsWith('.') && file.endsWith('.js'))
      .map(file => file.replace(/\.js$/, ''))
  } catch (error) {
    return []
  }
}

async function listVPSes(providerName, skipCache = false) {
  const { resolve } = require('node:path')
  const providerPath = resolve(__dirname, '../providers', `${providerName}.js`)
  
  try {
    // Check cache first (unless skipCache is true)
    if (!skipCache) {
      const cached = await getCachedVPSList(providerName)
      if (cached) {
        return cached
      }
    }
    
    // Load the provider module
    const provider = require(providerPath)
    
    // Get the service name from the provider
    let serviceName = `vps-${providerName}`
    if (typeof provider === 'function' && provider.serviceName) {
      serviceName = provider.serviceName
    } else if (provider.serviceName) {
      serviceName = provider.serviceName
    }
    
    // Try to load saved credentials
    let credentials = await loadCredentials(serviceName)
    
    // If no saved credentials, prompt for them
    if (!credentials) {
      console.log(`No saved credentials for ${providerName}`)
      credentials = await promptCredentials(providerName)
      await saveCredentials(serviceName, credentials.username, credentials.password)
    }
    
    // Call the provider's list function
    let vpses
    if (provider.list) {
      vpses = await provider.list(credentials)
    } else {
      console.error(`Provider '${providerName}' does not support listing VPSes.`)
      return []
    }
    
    // Cache the results
    await setCachedVPSList(providerName, vpses)
    
    return vpses
  } catch (error) {
    if (error.code === 'MODULE_NOT_FOUND') {
      console.error(`Provider '${providerName}' not found.`)
    } else {
      console.error(`Error listing VPSes for '${providerName}':`, error.message)
    }
    return []
  }
}

;(async function list() {
  // Parse arguments
  const args = process.argv.slice(2)
  let providerName = null
  let refresh = false
  let statusFilter = null
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i]
    if (arg === '--refresh' || arg === '-r') {
      refresh = true
    } else if (arg === '--status') {
      // Get the next argument as the status value
      if (i + 1 < args.length) {
        statusFilter = args[i + 1].toLowerCase()
        i++ // Skip the next argument since we consumed it
      }
    } else if (arg.startsWith('--status=')) {
      // Handle --status=value format
      statusFilter = arg.split('=')[1].toLowerCase()
    } else if (!arg.startsWith('-')) {
      providerName = arg
    }
  }
  
  if (refresh) {
    console.log('Refreshing...')
  }
  
  if (providerName) {
    // List VPSes from specific provider
    let vpses = await listVPSes(providerName, refresh)
    
    // Apply status filter if provided
    if (statusFilter) {
      vpses = vpses.filter(vps => vps.status && vps.status.toLowerCase() === statusFilter)
    }
    
    formatVPSList(vpses, providerName)
  } else {
    // List VPSes from all providers
    const providers = await listProviders()
    
    if (providers.length === 0) {
      console.log('No providers available.')
      console.log('Run `vps signin` to see available providers.')
      return
    }
    
    for (const provider of providers) {
      let vpses = await listVPSes(provider, refresh)
      
      // Apply status filter if provided
      if (statusFilter) {
        vpses = vpses.filter(vps => vps.status && vps.status.toLowerCase() === statusFilter)
      }
      
      formatVPSList(vpses, provider)
    }
  }
})()
